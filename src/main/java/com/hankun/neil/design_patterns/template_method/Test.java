package com.hankun.neil.design_patterns.template_method;

/**
 * 模板方法也是常用的设计模式，在业务逻辑固定且复杂时，使用模板方法可以大量减少代码
 * 典型的就是spring的update方法
 * 在jdbc servlet mybatis等几乎所有的框架中都有应用
 *
 * 该模式的主要优点如下。
 * 它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。
 * 它在父类中提取了公共的部分代码，便于代码复用。
 * 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。
 *
 * 该模式的主要缺点如下。
 * 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，间接地增加了系统实现的复杂度。
 * 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。
 * 由于继承关系自身的缺点，如果父类添加新的抽象方法，则所有子类都要改一遍
 * @author neil
 * @ClassName: Test
 * @Description: TODO
 * @date 2021/4/15 11:39
 */
public class Test {
    // 这个设计模式都不懂，那我也没办法，钩子啊，前端的钩子就是模板
    public static void main(String[] args) {

    }
}

//    行为型模式是 GoF 设计模式中最为庞大的一类，它包含以下 11 种模式。
//        模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
//        策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
//        命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
//        职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
//        状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
//        观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
//        中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
//        迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
//        访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
//        备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
//        解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。


